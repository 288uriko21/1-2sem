{Рыбинскова Ю.О.
109 группа
3 этап практикума #2
Нахождение корня уравнения F(x)=0 комбинированным методом
Нахождение определенного интеграла функции F(x) с помощью
формулы Симпсона}

Program finalIntegral (output);

uses kpro;

const g121 = 1.27;  {границы поиска пересечений графиков. Первые две цифры после g - номера гафиков,
                     которые пересекаются, последняя цифра - 1 - левая граница, 2 - правая}
      g122 = 1.28;
      g231 = 0.65;
      g232 = 0.66;
      g131 = -2.52;
      g132 = -2.53;

      eps=1E-10;
      eps1 = 0.1;
      eps2 = 1E-4;

var r1, r2, r3, S: real;

(**********************ПРОЦУДУРА***ROOT*********************************)
function root(F,F1:TF; a,b:real;  eps1:real): real;
var
  i:integer;
  buf1,buf2:real;

  (*************Приближение к корню методом хорд*****************)
  function ChordM(F: TF; a,b :real):real;
  begin
    ChordM:=(a*f(b)-b*f(a))/(f(b)-f(a));
  end;
  (**************************************************************)

  (***************Приближение к корню методом касательных********)
  function TanM(F,F1:TF; x:real):real; {}
  begin
    TanM:=x-(f(x)/f1(x))
  end;
  (**************************************************************)

  (************пошаговое приближение корня***************************)
  procedure Cycle(a,b,eps1:real);
  {var x:real;}
  begin
    while(abs(b-a)>eps1)do
    begin
      a:=ChordM(F,a,b);
      b:=TanM(F,F1,b);
      i:=i+1;
      root:=(a+b)/2;
    end
  end;
  (**************************************************************)
(******Тело*функции*root*****************************************)
begin
  buf1:=F((a+b)/2);
  buf2:=(F(a)+F(b))/2;
  root:=(a+b)/2;  {В качестве корня можно взять любую точку из отрезка [a,b],
               в частности, середину этого отрезка}
  i:=0;
  {Т. к. производимые вычисления недостаточно точны, то можно считать, что
  F(A)<0, (buf1-buf2)<0, если F(a)<eps, (buf1-buf2)<eps, где eps - какое-то
  очень маленькое число}
  if(((F(a)<eps)and(buf1-buf2<eps))or((F(a)>eps)and(buf1-buf2>eps)))
  then Cycle(a,b,eps1)
  else Cycle(b,a,eps1)
end;


(*****************Функция Integral**********************************************************)
function Integral(F: TF; a,b,eps2:real):real;
const
  n0=10;   {Начальное количество разбиений}
  p=1/15;
var n:integer;
    I1:real;  {I1 - значение In на очередной итерации}
    I2:real;  {I2 - значение I2n на очередной итерации}
    Sum:real;

  {Вычисляя интеграл по формуле Симпсона, в I2n на четных местах будут
  находиться слагаемые In, поэтому для экономии времени нужно сохранять
  сумму всех слагаемых In в параметре Spred}
  (********************************************************************)
  function I(F:TF;a,b:real; var Spred:real; n:integer): real;
  var j:integer;
      h:real;
      Sodd:real; {Сумма слагаемых на нечетных местах}
      SEven:real; {Сумма слагаемых на четных местах}
  begin
    h:=(b-a)/n;
    SOdd:=0;
    SEven:=Spred;
    if(n=n0) {Нахождение интеграла при n=n0}
    then begin
      SEven:=0;
      for j:=1 to n-1 do
      begin
        if odd(j)
        then Sodd:=Sodd+f(a+h*j)
        else SEven:=SEven+f(a+h*j);
      end;
      Spred:=SOdd+SEven
    end
    else begin
      for j:= 1 to n div 2 do
        SOdd:=SOdd+f(a+(2*j-1)*h);
      SPred:=Sodd+SEven
    end;
    I:=(4*SOdd+2*SEven+F(a)+F(b))*(h/3);
  end;
(******************************************************************)
(*********Тело*функции*integral************************************)
begin
  n:=n0;
  Sum:=0;
  I1:=I(F,a,b,Sum,n); {Нулевой шаг - значение интеграла при n=n0}
  n:=n*2;
  I2:=I(F,a,b,Sum,n);
  while(p*abs(I1-I2)>eps2)do
  begin
    I1:=I2;
    n:=n*2;
    I2:=I(F,a,b,Sum,n);
  end;
  Integral:=I2
end;

Begin
  writeln('Наши функции');
  writeln('1. y = 2^x+1  ');
  writeln('2. y = x^5 ');
  writeln('3. y = (1-x)/3 ');
  {*****Вычисление точек пересечения**********}
  r1:=root(f12, f112, g121, g122, eps1);
  writeln('Абсцисса точки пересечения графиков первой и второй функции: ', r1:10:6);
  r3:=root(f23, f123, g231, g232, eps1);
  writeln('Абсцисса точки пересечения графиков третьей и второй функции: ', r3:10:6);
  r2:=root(f13, f112, g131, g132, eps1);
  writeln('Абсцисса точки пересечения графиков первой и третьей функции: ', r2:10:6);
  {*******************************************}
  S:=integral(f1, r2, r1, eps2)-integral(f2, r3, r1, eps2)-integral(f3, r2, r3, eps2);
  writeln('Площадь фигуры, образованной точками пересечения графиков функций: ', S:10:6)
end.

