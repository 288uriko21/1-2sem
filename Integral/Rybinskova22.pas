{Рыбинскова Ю.О.
109 группа
2 этап практикума #2
Нахождение корня уравнения F(x)=0 комбинированным методом
Нахождение определенного интеграла функции F(x) с помощью
формулы Симпсона}

program prac22(input, output);
uses kpro;
const
  eps=1.0E-10;
  prec=8;  {Количество знаков после запятой при выводе корня и интеграла}

type
  TF=function(x:real):real;

var
  eps1,eps2,x,a,b:real;
  i, n1, n2:integer;
  f1,f: TF;
  beg, en: real; {Границы отрезка, на котором находится корень уравнения. Вычисляются из
  построения графика уравнения}

{Вычисление корня F(x)=0 на интервале [a,b] комбинированным методом
(F'(x) и F''(x) на данном отрезке не меняют знак).
Функции ChordM и TanM выполняют приближение к корню
Процедура Cycle пошагово выводит на экран значение корня}

(**********************ПРОЦУДУРА***ROOT*********************************)
procedure root(F,F1:TF; a,b:real;  eps1:real;  var x:real);
var
  i:integer;
  buf1,buf2:real;

  (*************Приближение к корню методом хорд*****************)
  function ChordM(F: TF; a,b :real):real;
  begin
    ChordM:=(a*f(b)-b*f(a))/(f(b)-f(a));
  end;
  (**************************************************************)

  (***************Приближение к корню методом касательных********)
  function TanM(F,F1:TF; x:real):real; {}
  begin
    TanM:=x-(f(x)/f1(x))
  end;
  (**************************************************************)

  (************ВЫВОД**КОРНЯ**ПОШАГОВО****************************)
  procedure Cycle(a,b,eps1:real);
  var x:real;
  begin
    while(abs(b-a)>eps1)do
    begin
      a:=ChordM(F,a,b);
      b:=TanM(F,F1,b);
      i:=i+1;
      x:=(a+b)/2;
      writeln(i,'-ая итерация:  ',x:prec+4:prec)
    end
  end;
  (**************************************************************)
(******Тело*функции*root*****************************************)
begin
  buf1:=F((a+b)/2);
  buf2:=(F(a)+F(b))/2;
  x:=(a+b)/2;  {В качестве корня можно взять любую точку из отрезка [a,b],
               в частности, середину этого отрезка}
  i:=0;
  {Т. к. производимые вычисления недостаточно точны, то можно считать, что
  F(A)<0, (buf1-buf2)<0, если F(a)<eps, (buf1-buf2)<eps, где eps - какое-то
  очень маленькое число}
  if(((F(a)<eps)and(buf1-buf2<eps))or((F(a)>eps)and(buf1-buf2>eps)))
  then Cycle(a,b,eps1)
  else Cycle(b,a,eps1)
end;
(************************************************************************)

{Вычисление интеграла функции на заданом отрезке с помощью формулы Симпсона
и с заданной точностью eps2. eps2 считается достигнутой, если
p*abs(I1-I2)<eps2 - из правила Рунге
(Значение константы p взято из п.5 на с.5 книги "Задания практикума на ЭВМ")
Функция I вычисляет значение I для функции F на сегменте [a,b] при заданном n}
function Integral(F: TF; a,b,eps2:real; var nit:integer):real;
const
  n0=10;   {Начальное количество разбиений}
  p=1/15;
var n:integer;
    I1:real;  {I1 - значение In на очередной итерации}
    I2:real;  {I2 - значение I2n на очередной итерации}
    Sum:real;

  {Вычисляя интеграл по формуле Симпсона, в I2n на четных местах будут
  находиться слагаемые In, поэтому для экономии времени нужно сохранять
  сумму всех слагаемых In в параметре Spred}
  (********************************************************************)
  function I(F:TF;a,b:real; var Spred:real; n:integer): real;
  var j:integer;
      h:real;
      Sodd:real; {Сумма слагаемых на нечетных местах}
      SEven:real; {Сумма слагаемых на четных местах}
  begin
    h:=(b-a)/n;
    SOdd:=0;
    SEven:=Spred;
    if(n=n0) {Нахождение интеграла при n=n0}
    then begin
      SEven:=0;
      for j:=1 to n-1 do
      begin
        if odd(j)
        then Sodd:=Sodd+f(a+h*j)
        else SEven:=SEven+f(a+h*j);
      end;
      Spred:=SOdd+SEven
    end
    else begin
      for j:= 1 to n div 2 do
        SOdd:=SOdd+f(a+(2*j-1)*h);
      SPred:=Sodd+SEven
    end;
    I:=(4*SOdd+2*SEven+F(a)+F(b))*(h/3);
  end;
(******************************************************************)
(*********Тело*функции*integral************************************)
begin
  n:=n0;
  Sum:=0;
  nit:=0;
  I1:=I(F,a,b,Sum,n); {Нулевой шаг - значение интеграла при n=n0}
  n:=n*2;
  I2:=I(F,a,b,Sum,n);
  while(p*abs(I1-I2)>eps2)do
  begin
    nit:=nit+1;
    I1:=I2;
    n:=n*2;
    I2:=I(F,a,b,Sum,n);
  end;
  Integral:=I2;
  nit:=nit+1;
end;
(******конец*функции*integral************************************************)

(*****тело*программы*********************************************************)
begin
  writeln('Решение уравнения F(x)=0 c некоторой точностью');
  writeln('с использованием комбинированного метода');
  writeln('(метода хорд и касательных).');
  writeln('Выберите функции, с которыми хотите работать (введите две соответствующие цифры через пробел)');
  writeln('1. y = 2^x+1  ');
  writeln('2. y = x^5 ');
  writeln('3. y = (1-x)/3 ');
  readln(n1, n2);
  if (n1<1) or (n1>3) or (n2<1) or (n2>3) then
     writeln('У нас на выбор только 3 функции с номерами 1, 2 и 3.')

  else begin {определяем, пересечение графиков КАКИХ функций ищем}
     case n1+n2 of
          3: begin  f:=f12; f1:=f112; writeln('g = 2^x+1-x^5'); beg:=1; en:=2  end;
          4: begin  f:=f13; f1:=f113; writeln('g = (1-x)/3-2^x-1'); beg:=-3; en:=-2 end;
          5: begin  f:=f23; f1:=f123; writeln('g =(1-x)/3-x^5');  beg:=0; en:=1 end;
     end;

     writeln('Введите точность eps1, с которой будет получен корень(eps1>0):');
     writeln('(Точность не меньше 1.0E-',prec,'):');
     readln(eps1);
     if(eps1<0)
        then writeln('Введена неверная точность')
     else begin
        writeln('В следующих строках будет пошагово вычисляться корень');
        root(f,f1,beg,en,eps1,x);
     end;
     writeln('Вычисление определенного интеграла от функции g(x)');
     writeln('на отрезке [a,b] с использованием формулы Симпсона.');
     writeln('Введите точность eps2, с которой будет вычислен интеграл(eps2>0)');
     writeln('(Точность не меньше 1.0E-',prec,'):');
     readln(eps2);
     if(eps2<0)
      then writeln('Введена неверная точность!')
      else begin
         writeln('Введите 2 числа a и b ');
         readln(a,b);
         if(a>b+eps)then
            writeln('a>b. Error!')
         else begin
            write('Значение интеграла с заданной точностью равно:  ');
            i:=0;
            writeln(integral(F,a,b,eps2,i):prec+4:prec);
            writeln('Кол-во пройденных итераций: ',i)
         end
      end
  end
end.
(****************************************************************************)
(*Тесты:
#  *    Ввод     *   Вывод
******************************************************
1  *  2 3        *  0.89029255
   *   0.0001    *  0.71307938
   *             *  0.65644009
   *             *  0.65057767
   *  0.00001    *
   *   -2 -3     *  Error!
******************************
2  *    1 2      *  1.35967436
   *  0.00001    *  1.29407746
   *             *  1.27995158
   *             *  1.27935274
   *             *  1.27935319
   *             *  1.27935319
   * 0.00000001  *
   *    1   2    * -6.61460992
*******************************
3  *    1 3      * -0.51513898
   * 0.00000001  * -2.04293848
   *             * -2.50142324
   *             * -2.52218873
   *  0.000001   * -2.52222342
   *    -3 -2    *
   *             * -0.01367021
*******************************
4  *    4 -5     *  Error
   *             *
*******************************
5  *    1 2      *  1.35967436
   *    0.000001 *  1.29407746
   *             *  1.27995158
   *             *  1.27935274
   *             *  1.27935319
   *             *  1.27935319
   *  0.000001   *
   *  -4 -3      *562.25683602
***********************************
*)
