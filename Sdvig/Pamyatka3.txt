” названи€ кода операции сдвига влево $shl$ (она называетс€ логическим сдвигом влево), есть синоним $sal$, который 
называетс€ арифметическим сдвигом влево. 
¬ том случае, если операнд команды сдвига влево на один бит трактуетс€ как целое число, то результатом сдвига 
€вл€етс€ умножение этого числа на два. ѕри этом результат умножени€ получаетс€ правильным, если во флаг переноса 
CF попадает незначащий бит результата. “аким образом, дл€ беззнакового числа при правильном умножении на 2 должно 
быть $CF=0$. ј вот дл€ знакового операнда результат получаетс€ правильным только тогда, когда значение флага переноса
совпадает со знаковым (крайним слева) битом результата, т.е. после выполнени€ команды сдвига справедливо равенство 
$CF=op1[N]=SF$ (в этом случае флаг переполнени€ $OF=0$). “аким образом, правильность умножени€ на два с помощью команды 
сдвига влево можно контролировать, как обычно, анализиру€ флаги переноса $CF$ и переполнени€ $OF$ дл€ беззнаковых и 
знаковых чисел соответственно.
¬ отличие от сдвигов влево, сдвиги вправо существубт две различные команды: $sar$, $shr$.
  $sar op1,1$
она выполн€етс€ по правилу:
  $CF:=op1[0];
  for i:=0 to N-1 do op1[i]:=op1[i+1]$