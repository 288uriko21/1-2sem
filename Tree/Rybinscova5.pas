{Рыбинскова Ю.О.
 109 группа
 задание практикума №5
 изобразить на экране дерево корнем вниз, возможно введение ограничений на высоту}

Program Tre(input, output);

const  ri = 25; {"высота" массива,выводимого на экран}
       rj = 141; {"длина" массива --//--}
       otstup = 4;{расстояние в высоту между уровнями дерева при выводе на экран}
       levelDis = 64; {ограничение на глубину (номер первого запрещённого элемента)}

Type  tree = ^zp;
       zp = record  {тип дерева}
           L: tree;
           R: tree;
           inf: char
       end;

var T: tree;
    deep: integer;

{///////////////////////////////////////////////////////////////////////////////////////////////////////}
(***********Создание**дерева****************************************************************************)
Procedure create(var T: tree; var deep: integer);

function find(a: integer): integer;
var k,s: integer;
begin
  k:=4;
  s:=1;
  while k<a do begin
      k:=k*2;
      s:=s+1
  end;
  find:=s
end;

(***********Рекурсивная часть создания******************************************************************)
Procedure cr(var T: tree; elem: integer);
var c: char;
    i: integer;
begin
  T^.R:=nil;
  T^.L:=nil;
  if elem < levelDis then begin
     writeln('Правый элемент? Текущий элемент:', elem);
     i:=find(elem);
     if deep<i then
        deep:=i;
     readln(c);
     if c<>'-' then begin
        new(T^.R);
        T^.R^.inf:=c;
        cr(T^.R, 2*elem+1);
     end
     else
        T^.R:=nil;

     writeln('Левый элемент? От ', elem);
     readln(c);
     if c<>'-' then begin
        new(T^.L);
        T^.L^.inf:=c;
        cr(T^.L, 2*elem)
     end
     else
        T^.L:=nil;
  end
  else
    writeln('!Достигуна максимальная глубина дерева!');
end;
(*******************************************************************************************************)

begin
  writeln('Введите корневой элемент дерева символов');
  new(T);
  deep:=0;
  readln(T^.inf);
  writeln('Максимальная высота дерева - 6.');
  writeln('Для наблидения красивой картинки дерева стоит развернуть консоль на весь экран');
  writeln('Далее вводите "-", если запрашиваемого элемента или численное значение запрашиваемого элемента(c определенной стороны от пердыдущего)');
  writeln('Нумерация как в строго двоичном дереве(считаем, что несуществующие элементы тоже занумерованы)');
  writeln('По уровням слева-направо');
  cr(T, 1);
end;
{///////////////////////////////////////////////////////////////////////////////////////////////////////}
(*******************************************************************************************************)


{///////////Вывод корнем вниз///////////////////////////////////////////////////////////////////////////}
(*******************************************************************************************************)
Procedure output(T: tree; deep:integer);
var a: array[1..ri] of array[1..rj] of char;
    i, j: integer;

(************рекурсивная часть вывода********************************************************************)
Procedure rec(T: tree; i,j,d: integer); {i,j - позиция в матрице, куда будет записан элемент, на который
ссылается T , d - глубина, на которой данный элемент находится, нумерация уровней с 0}
var k, shift: integer;
begin
  if T<>nil then begin
      a[i,j]:=T^.inf;
      shift:=round(exp(ln(2)*deep)/exp(ln(2)*d));  {сдвиг по пробелам дочерних элементов относительно текущего (одна из ключевых строк)}
      if T^.R<>nil then
        for k:=1 to otstup-1 do
            a[i+k, j+round((shift/otstup)*k)]:='/';
      if T^.L<>nil then
        for k:=1 to otstup-1 do
            a[i+k,j-round((shift/otstup)*k)]:='\';
      rec(T^.L, i+otstup,j-shift, d+1);
      rec(T^.R, i+otstup,j+shift, d+1)
  end
end;
(*******************************************************************************************************)

begin
  for i:=1 to ri do   {изначальное заполнение массива}
      for j:=1 to rj do
          a[i,j]:='-';
  rec(T, 1, round(rj/2), 0);
   for i:=(deep)*otstup+1 downto 1 do begin {выводим только те строки, в которых располагаются элементы дерева}
      for j:=1 to rj do begin
          if a[i,j]<>'-' then {выводим только значащие элементы}
              write(a[i,j])
          else
              write(' ');
      end;
      writeln
   end
end;
{///////////////////////////////////////////////////////////////////////////////////////////////////////}
(*******************************************************************************************************)

begin
  create(T, deep);
  output(T, deep);
end.

{
  Дерево выводится на экран при помощи вспомогательного массива, заполняемого прочерками, значащими элементами дерева
 или чёрточками между элементами. Формула отступа  round(exp(ln(2)*deep)/exp(ln(2)*d)) (2^(deep)/2^(d)), где deep
 - общая глубина дерева, d - глубина, на которой находится данный элемент дерева).
 Эта формулабыла выведена с помощью рисования деревьев с различной глубиной на листочке, так, чтобы на последнем
 уровне отступ между элементами был минимальным. Так, можно заметить, что, во-первых на N-ом уровне 2^(N) элементов
 (если нумеровать уровни с 0). Тогда посмотрим на дерево от листовых элементов. Если они сдвинуты от своих родительских
 элементов всего на 1 позицию по горизонтали, то, в свою очередь родительские элементы будут сдвинуты от своих
 родительских на 2 позиции по горизонтали. Это следует из того, что сдвиг увеличится на "предыдущий" + расстояние между
 "не братьями". Иначе говоря, сдвиг увеличится в 2 раза. Так будет происходить, если мы аналогичным образом будем далее
 подниматься по дереву. Таким образом, формула сдвига: 2^(deep)/2^(d).
  Соединительные палочки же добавляются следующим образом: при наличии правой или левой ветки у узла, делим, округляя,
 отступ до дочернего элемента на 4 и заполняем 4 пропущенные между уровнями строки матрицы / или \ с отступом при
 переходе на новую строку в ~1/4 отступа до дочернего элемента.
}




